{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Django Hatchway","text":""},{"location":"#what-is-it","title":"What is it?","text":"<p>Hatchway is an API framework inspired by the likes of FastAPI,  but while trying to keep API views as much like standard Django views as possible.</p> <p>It was built for, and extracted from, Takah\u0113. If you want to see an example of it being used, browse its api app.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>$ pip install django-hatchway\n\n---&gt; 100%\n</code></pre> <p>Add <code>hatchway</code> to your <code>INSTALLED_APPS</code>:</p> <pre><code>INSTALLED_APPS = [\n    \"hatchway\",\n]\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>To make a view an API endpoint, you should write a standard function-based view, and decorate it with <code>@api_view</code>:</p> <pre><code>\"\"\"myapp/api.py\"\"\"\nfrom hatchway import api_view\n\n@api_view.get\ndef my_view(request):\n    return {\"hello\": \"world\"}\n</code></pre> <p>The types of your function arguments matter. Hatchway will use them to work out where to get their values from and how to parse them. All the standard Python types are supported, plus Pydantic-style models  (which ideally you should build based on the hatchway.Schema base class, as it understands how to load things from Django model instances).</p> <p>Your return type also matters - this is what Hatchway uses to work out how to format/validate the return value.  You can leave it off, or set it to Any, if you don't want any return validation.</p>"},{"location":"#url-patterns","title":"URL patterns","text":"<p>You add API views in your 'urls.py' file as you would any other view:</p> <pre><code>\"\"\"myapp/urls.py\"\"\"\nfrom django.urls import path\nfrom myapp.api import my_api_endpoint\n\nurlpatterns = [\n    path(\"api/test/\", my_api_endpoint),\n]\n</code></pre> <p>The view will only accept the method it was decorated with (e.g. GET for <code>@api_view.get</code>)</p> <p>If you want to have two or more views on the same URL but responding to different methods, use Hatchway's <code>methods</code> object:</p> <pre><code>from django.urls import path\nfrom hatchway import methods\nfrom myapp.api import posts\n\nurlpatterns = [\n    path(\n        \"api/post/&lt;id&gt;/\",\n        methods(\n            get=posts.post_get,\n            delete=posts.posts_delete,\n        ),\n    ),\n]\n</code></pre>"},{"location":"#argument-sourcing","title":"Argument Sourcing","text":"<p>There are four places that input arguments can be sourced from:</p> <ul> <li>Path: The URL of the view, as provided via kwargs from the URL resolver</li> <li>Query: Query parameters (request.GET)</li> <li>Body: The body of a request, in either JSON, formdata, or multipart format</li> <li>File: Uploaded files, as part of a multipart body</li> </ul> <p>By default, Hatchway will pull arguments from these sources:</p> <ul> <li>Standard Python singular types (int, str, float, etc.): Path first, and then Query</li> <li>Python collection types (list[int], etc.): Query only, with implicit list conversion of either one or multiple values</li> <li>hatchway.Schema/Pydantic BaseModel subclasses: Body only (see Model Sourcing below)</li> <li>django.core.files.File: File only</li> </ul> <p>You can override where Hatchway pulls an argument from by using one of the  <code>Path</code>, <code>Query</code>, <code>Body</code>, <code>File</code>, <code>QueryOrBody</code>, <code>PathOrQuery</code>, or <code>BodyDirect</code> annotations:</p> <pre><code>from hatchway import api_view, Path, QueryOrBody\n\n@api_view.post\ndef my_api_endpoint(request, id: Path[int], limit: QueryOrBody[int] = 100) -&gt; dict:\n    ...\n</code></pre> <p>While <code>Path</code>, <code>Query</code>, <code>Body</code> and <code>File</code> force the argument to be picked from only that source, there are some more complex ones in there:</p> <ul> <li><code>PathOrQuery</code> first tries the Path, then tries the Query (the default for simple types)</li> <li><code>QueryOrBody</code> first tries the Query, then tries the Body</li> <li><code>BodyDirect</code> forces top-level population of a model - see Model Sourcing, below.</li> </ul>"},{"location":"#model-sourcing","title":"Model Sourcing","text":"<p>When you define a <code>hatchway.Schema</code> subclass (or any other pydantic model subclass), Hatchway will presume that it should pull it from the POST/PUT/etc. body.</p> <p>How it pulls it depends on how many body-sourced arguments you have:</p> <ul> <li>If you just have one, it will feed it the top-level keys in the body data as its internal values.</li> <li>If you have more than one, it will look for its data in a sub-key named the same as the argument name.</li> </ul> <p>For example, this function has two body-sourced things (one implicit, one explicit):</p> <pre><code>\"\"\"myapp/api.py\"\"\"\nfrom hatchway import api_view, Body\nfrom myapp import schemas\n\n@api_view.post\ndef my_api_endpoint(request, thing: schemas.MyInputSchema, limit: Body[int] = 100):\n    ...\n</code></pre> <p>This means Hatchway will feed the <code>schemas.MyInputSchema</code> model whatever it finds under the <code>thing</code> key in the request body as its input, and <code>limit</code> will come from the <code>limit</code> key.</p> <p>If <code>limit</code> wasn't specified, then there would be only one body-sourced item, and Hatchway would feed <code>schemas.MyInputSchema</code> the entire request body as its input.</p> <p>You can force a schema subclass to be fed the entire request body by using the <code>BodyDirect[MySchemaClass]</code> annotation on its type.</p>"},{"location":"#return-values","title":"Return Values","text":"<p>The return value of an API view, if provided, is used to validate and coerce the type of the response:</p> <pre><code>\"\"\"myapp/api.py\"\"\"\nfrom hatchway import api_view\n\n@api_view.delete\ndef my_api_endpoint(request) -&gt; int:\n    ...\n</code></pre> <p>It can be either a normal Python type, or a <code>hatchway.Schema</code> subclass. If it is a Schema subclass, the response will be fed to it for coercion,  and ORM objects are supported - returning a model instance, a dict with the model instance values, or an instance of the schema are all equivalent.</p> <p>A typechecker will honour these too,  so we generally recommend returning instances of your Schema so that your entire view benefits from typechecking, rather than relying on the coercion. You'll get typechecking in your Schema subclass constructors, and then typechecking that you're always returning the right things from the view.</p> <p>You can also use generics like <code>list[MySchemaClass]</code> or <code>dict[str, MySchemaClass]</code> as a response type;  generally, anything Pydantic allows, we do as well.</p>"},{"location":"#adding-headersstatus-codes-to-the-response","title":"Adding Headers/Status Codes to the Response","text":"<p>If you want to do more to your response than just sling some data back at your client, you can return an <code>ApiResponse</code> object instead of a plain value:</p> <pre><code>\"\"\"myapp/api.py\"\"\"\nfrom hatchway import api_view, ApiResponse\n\n@api_view.delete\ndef my_api_endpoint(request) -&gt; ApiResponse[int]:\n    ...\n    return ApiResponse(42, headers={\"X-Safe-Delete\": \"no\"})\n</code></pre> <p><code>ApiResponse</code> is a standard Django <code>HTTPResponse</code> subclass,  so accepts almost all of the same arguments,  and has most of the same methods. Just don't edit its <code>.content</code> value; if you want to mutate the data you passed into it, that is stored in <code>.data</code>.</p> <p>Note that we also changed the return type of the view so that it would pass typechecking; <code>ApiResponse</code> accepts any response type as its argument and passes it through to the same validation layer.</p>"},{"location":"#auto-collections","title":"Auto-Collections","text":"<p>Hatchway allows you to say that Schema subclasses can pull their values from individual query parameters or body values; these are normally flat strings, though, unless you're looking at a JSON-encoded body, or multiple repeated query parameters.</p> <p>However, it will respect the use of <code>name[]</code> to make lists, and <code>name[key]</code> to make dicts. Some examples:</p> <ul> <li>A <code>a=Query[list[int]]</code> argument will see <code>url?a=1</code> as <code>[1]</code>, <code>url?a=1&amp;a=2</code> as <code>[1, 2]</code>, and <code>url?a[]=1&amp;a[]=2</code> as <code>[1, 2]</code>.</li> <li>A <code>b=Body[dict[str, int]]</code> argument will correctly accept the POST data <code>b[age]=30&amp;b[height]=180</code> and give you <code>{\"age\": 30, \"height\": 180}</code>.</li> </ul> <p>These will also work in JSON bodies too, though of course you don't need them there; nevertheless, they still work for compatibility reasons.</p>"}]}